---
title: CBOR tags for IPv4 and IPv6 addresses and prefixes
abbrev: CBOR-IP
docname: draft-ietf-cbor-network-addresses-04

stand_alone: true

ipr: trust200902
area: Internet
wg: CBOR Working Group
kw: Internet-Draft
cat: std
consensus: true

pi:    # can use array (if all yes) or hash here
  toc: yes
  sortrefs:   # defaults to yes
  symrefs: yes

author:


- ins: M. Richardson
  name: Michael Richardson
  org: Sandelman Software Works
  email: mcr+ietf@sandelman.ca

normative:
  RFC8949:

informative:

--- abstract

This document describes two CBOR Tags to be used with IPv4 and IPv6 addresses and prefixes.

RFC-EDITOR-please remove: This work is tracked at https://github.com/cbor-wg/cbor-network-address

--- middle

# Introduction

{{RFC8949}} defines a number of CBOR Tags for common items.

Not included are ones to indicate if the item is an IPv4 or IPv6 address, or if it is an
address plus prefix length.
This document defines them.

# Terminology

{::boilerplate bcp14}

# Protocol

These tags can applied to byte strings to represent a single address.

When applied to an array, the represent a CIDR-style prefix.
When a byte string (without prefix) appears in a context where a prefix is expected, then it is to be assumed that all bits are relevant.
That is, for IPv4, a /32 is implied, and for IPv6, a /128 is implied.

## IPv6

IANA has allocated tag 54 for IPv6 uses.
(Note that this is the ASCII code for '6'.)

An IPv6 address is to be encoded as a sixteen-byte byte string ({{RFC8949}} section, 3.1, major type 2), prefixed with Tag(54).

An IPv6 prefix, such as 2001:db8:1234::/48 is to be encoded as a two element array, with the length of the prefix first.
Trailing zero bytes MUST be omitted.

For example:

~~~~
54([ 48, h'20010db81234'])
~~~~

## IPv4

IANA has allocated tag 54 for IPv4 uses.
(Note that this is the ASCII code for '4'.)

An IPv4 address is to be encoded as a four-byte byte string ({{RFC8949}} section, 3.1, major type 2), prefixed with Tag(52).

An IPv4 prefix, such as 192.0.2.1/24 is to be encoded as a two element array, with the length of the prefix first.
Trailing zero bytes MUST be omitted.

For example:

~~~~
52([ 24, h'C00002'])
~~~~

# Encoder Consideration for prefixes

An encoder may omit as many right-hand (trailing) bytes which are all zero as it wishes.

There is no relationship between the number of bytes omitted and the prefix length.
For instance, the prefix 2001:db8::/64 is optimally encoded as:

~~~~
54([64, h'20010db8'])
~~~~

An encoder MUST take care to set all trailing bits to zero.  While decoders are expected to ignore them, such garbage entities could be used as a covert channel, or may reveal the state of what would otherewise be private memory contents.  So for example, 2001:db8:1230::/44
MUST be encoded as:

~~~~
52([44, h'20010db81230'])
~~~~

even though variations like:

~~~~
54([44, h'20010db81233'])  WRONG
54([45, h'20010db8123f'])  WRONG
~~~~

would be parsed in the exact same way.

The same considerations apply to IPv4 prefixes.

# Decoder Considerations for prefixes

A decoder MUST consider all bits to the right of the prefix length to be zero.

A decoder MUST handle the case where a prefix length specifies that more bits are relevant than are actually present in the byte-string.  As a pathological case, ::/128 can be
encoded as

~~~~
54([128, h''])
~~~~

A recommendation for implementation is to first create an array of 16 (or 4) bytes in size, set it all to zero.

Then looking at the length of the included byte-string, and of the
prefix-length, rounded up to the next multiple of 8, and taking whichever is smaller,
copy that many bytes from the byte-string into the array.

Finally, looking at the last three bits of the prefix-length (that is, the prefix-length modulo 8), use a static array of 8 values to force the lower bits, non-relevant bits to zero.

A particularly paranoid decoder could examine the lower non-relevant bits to determine if they are non-zero, and reject the prefix.
This would detect non-compliant encoders, or a possible covert channel.

# Security Considerations

Identifying which byte sequences in a protocol are addresses may allow an attacker or eavesdropper to better understand what parts of a packet to attack.

Reading the relevant RFC may provide more information, so it would seem that any additional
security that was provided by not being able to identify what are IP addresses falls into the security by obscurity category.

The right-hand bits of the prefix, after the prefix-length, are ignored by this protocol.
A malicious party could use them to transmit covert data in a way that would not affect the primary use of this encoding.
Such abuse would be detected by examination of the raw protocol bytes.
Users of this encoding should be aware of this possibility.

# IANA Considerations

IANA has allocated two tags from the Specification Required area of the Concise Binary Object Representation (CBOR) Tags:

## Tag 54 - IPv6

~~~~
Data Item: byte string or array
Semantics: IPv6 or [prefixlen,IPv6]
~~~~

## Tag 52 - IPv4

~~~~
Data Item: byte string or array
Semantics: IPv4 or [prefixlen,IPv4]
~~~~


--- back

# Changelog
{: removeinrfc="true"}

* 03
* 02
* 01 added security considerations about covert channel

# Acknowledgements
{: numbered="false"}

none yet
